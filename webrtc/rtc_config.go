package webrtc

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base64"
	"errors"
	"fmt"
	"time"
	"github.com/xcheng85/turn-discovery-service/utils"
)

// http://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer
type ICEServer struct {
	URLs       []string `json:"urls"`
	UserName   string   `json:"username,omitempty"`
	Credential string   `json:"credential,omitempty"`
}

// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
type RTCPeerConnection struct {
	LifetimeDuration   string      `json:"lifetimeDuration,omitempty"`
	IceServers         []ICEServer `json:"iceServers"`
	BlockStatus        string      `json:"blockStatus,omitempty"`
	IceTransportPolicy string      `json:"iceTransportPolicy,omitempty"`
}

// generates time-limited TURN credential. For authentiation, each connection requires: username and password.
// password is temporary and it is generated by this web-server on demand with the following algorithm:
// tmp-password = base64_encode(hmac-sha1(shared-secret, tmp-username))
func makeCredential(user string, secret string, ttlSeconds uint64) (string, string) {
	var tmpUserName, tmpPassword string
	ttlOneDay := time.Duration(ttlSeconds) * time.Second
	nowPlusTTL := time.Now().Add(ttlOneDay).Unix()
	// timestamp/username sep symbol must match coturn server configuration
	separator := "-"
	tmpUserName = fmt.Sprintf("%d%s%s", nowPlusTTL, separator, user)
	encryptKey := []byte(secret)
	mac := hmac.New(sha1.New, encryptKey)
	// string to byte slice
	mac.Write([]byte(tmpUserName))
	tmpPassword = base64.StdEncoding.EncodeToString(mac.Sum(nil))
	return tmpUserName, tmpPassword
}

// ltCredMech requires extra predefined username and password
func MakeRTCPeerConnection(ips []string, port string, user string, secret string, ttlSeconds uint64, useLtCredMech bool,
	usernameLt string, passwordLt string) (RTCPeerConnection, error) {
	var config RTCPeerConnection

	if len(ips) == 0 {
		return config, utils.NewCustomError(utils.RtcMissingExternalIp.String(), errors.New("ips slice is empty"))
	}

	tmpUserName, tmpPassword := makeCredential(user, secret, ttlSeconds)

	publicStunServerUrls := []string{
		"stun:stun.l.google.com:19302",
	}
	stunServerUrls := []string{}
	turnServerUrls := []string{}

	stunServerUrls = append(stunServerUrls, publicStunServerUrls...)
	for _, ip := range ips {
		stunServerUrls = append(stunServerUrls, fmt.Sprintf("stun:%s:%s", ip, port))
		turnServerUrls = append(turnServerUrls, fmt.Sprintf("turn:%s:%s?transport=tcp", ip, port))
		turnServerUrls = append(turnServerUrls, fmt.Sprintf("turn:%s:%s?transport=udp", ip, port))
	}
	iceServers := []ICEServer{}
	if len(stunServerUrls) > 0 {
		iceServers = append(iceServers, ICEServer{
			URLs: stunServerUrls,
		})
	}

	if len(turnServerUrls) > 0 {
		if useLtCredMech {
			iceServers = append(iceServers, ICEServer{
				URLs:       turnServerUrls,
				UserName:   usernameLt,
				Credential: passwordLt,
			})
		} else {
			iceServers = append(iceServers, ICEServer{
				URLs:       turnServerUrls,
				UserName:   tmpUserName,
				Credential: tmpPassword,
			})
		}
	}
	
	config.LifetimeDuration = fmt.Sprintf("%ds", ttlSeconds)
	config.BlockStatus = "NOT_BLOCKED"
	config.IceTransportPolicy = "all"
	config.IceServers = iceServers

	return config, nil
}
